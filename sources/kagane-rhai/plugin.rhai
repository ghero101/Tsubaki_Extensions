// Kagane Scraper Add-on (Rhai)
// Browser-first scraper for kagane.org
//
// Kagane is a Next.js site with Cloudflare protection where ALL content is
// client-side rendered by React. The server returns only a ~52KB HTML shell
// with JS bundle links — no actual manga data. Browser automation is the
// ONLY method that can render the React content.
//
// URL Patterns:
//   Homepage:  /
//   Series:    /series/{ALPHANUMERIC_ID}
//   Reader:    /series/{SERIES_ID}/reader/{CHAPTER_ID}#chapter-N-slug
//   Search:    /search?q={query}
//
// IDs are 26-char uppercase alphanumeric strings (e.g., 31C41EQARWFF79NXEJIIM32U95)
//
// Image note: ALL cover/page images are blob: URLs generated by JS at runtime.
// These cannot be extracted via HTML scraping. Covers are left empty (metadata
// providers like AniList can supply them). Chapter pages require JS execution.

const BASE_URL = "https://kagane.org";

// ============================================================================
// Content Validation
// ============================================================================

/// Check if HTML contains real rendered content (not just the Next.js shell).
/// The shell is ~52KB but contains none of these markers that only appear
/// after React hydration.
fn has_real_content(html) {
    html.contains("aria-label=") || html.contains("data-slot=") || html.contains("/reader/")
}

// ============================================================================
// Fetch Helpers — Browser FIRST
// ============================================================================

/// Fetch a page using browser automation first (required for Next.js rendering).
/// Falls back to FlareSolverr then HTTP, but these will return the empty shell.
fn fetch_page(url, wait_selector) {
    // Method 1: Browser automation (ONLY method that renders React content)
    if browser_is_available() {
        try {
            let browser_id = browser_launch_stealth();
            browser_goto(browser_id, url);
            browser_wait_for_cloudflare(browser_id, 35000);

            // Wait for React to render actual content
            try {
                browser_wait_for_selector(browser_id, wait_selector, 25000);
            } catch {
                // Selector might not match exactly, wait for any real content
                try {
                    browser_wait_for_selector(browser_id, "a[aria-label], div[data-slot='card'], h1", 15000);
                } catch {}
            }

            let html = browser_get_html(browser_id);
            browser_close(browser_id);

            if html != "" && has_real_content(html) {
                return html;
            }
        } catch {
            // Browser failed, fall through
        }
    }

    // Method 2: FlareSolverr fallback (solves Cloudflare but returns pre-render shell)
    if flaresolverr_is_available() {
        try {
            let html = flaresolverr_get(url, 60000);
            if html != "" && has_real_content(html) {
                return html;
            }
        } catch {
            // Fall through to HTTP
        }
    }

    // Method 3: HTTP fallback (will get Cloudflare blocked or empty shell)
    try {
        let headers = #{
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.5",
            "Referer": BASE_URL
        };
        return http_get_with_headers(url, headers);
    } catch {
        return "";
    }
}

/// Fetch a page and also execute a JavaScript snippet in the browser context.
/// Returns #{ html, script_result }.
fn fetch_page_with_script(url, wait_selector, script) {
    if browser_is_available() {
        try {
            let browser_id = browser_launch_stealth();
            browser_goto(browser_id, url);
            browser_wait_for_cloudflare(browser_id, 35000);

            try {
                browser_wait_for_selector(browser_id, wait_selector, 25000);
            } catch {
                try {
                    browser_wait_for_selector(browser_id, "body", 10000);
                } catch {}
            }

            let script_result = "";
            try {
                script_result = browser_execute_script(browser_id, script);
            } catch {}

            let html = browser_get_html(browser_id);
            browser_close(browser_id);

            return #{ html: html, script_result: script_result };
        } catch {
            return #{ html: "", script_result: "" };
        }
    }

    return #{ html: "", script_result: "" };
}

// ============================================================================
// ID Extraction Helpers
// ============================================================================

/// Extract series ID from a URL path.
/// /series/31C41EQARWFF79NXEJIIM32U95 -> 31C41EQARWFF79NXEJIIM32U95
fn extract_series_id(url) {
    let result = regex_find("/series/([A-Za-z0-9]{20,})", url);
    if result != "" {
        return result.replace("/series/", "");
    }
    ""
}

/// Extract chapter ID from a reader URL, stripping the hash fragment.
/// /series/{SID}/reader/{CID}#chapter-1-slug -> CID
fn extract_chapter_id(href) {
    // Strip hash fragment first
    let clean = href;
    let hash_idx = href.index_of("#");
    if hash_idx > 0 {
        clean = href.sub_string(0, hash_idx);
    }

    let result = regex_find("/reader/([A-Za-z0-9]{20,})", clean);
    if result != "" {
        return result.replace("/reader/", "");
    }
    ""
}

/// Map status text to standard format
fn map_status(status) {
    let s = status.to_upper().trim();
    if s.contains("ONGOING") {
        return "Ongoing";
    } else if s.contains("COMPLETED") {
        return "Completed";
    } else if s.contains("HIATUS") {
        return "Hiatus";
    } else if s.contains("CANCELLED") {
        return "Cancelled";
    }
    status
}

// ============================================================================
// Series List Extraction (shared by browse, search, get_latest_updates)
// ============================================================================

/// Parse series entries from rendered HTML containing series cards.
/// Works for homepage, search results, and any page with series cards.
fn extract_series_list(html) {
    let series = [];
    let seen = #{};

    // Primary: aria-label links — "Open series {Title}" with href="/series/{ID}"
    let series_links = html_select(html, "a[aria-label]");

    for link in series_links {
        let aria = element_attr(link, "aria-label");
        if aria == () || aria == "" {
            continue;
        }
        if !aria.starts_with("Open series ") {
            continue;
        }

        let href = element_attr(link, "href");
        if href == () || href == "" {
            continue;
        }
        if !href.contains("/series/") || href.contains("/reader/") {
            continue;
        }

        let sid = extract_series_id(href);
        if sid == "" || seen[sid] != () {
            continue;
        }
        seen[sid] = true;

        // Title from aria-label: "Open series {Title}" -> "{Title}"
        let title = aria.sub_string(12);
        if title == "" || title.len() < 2 {
            continue;
        }

        series.push(#{
            id: sid,
            title: title,
            url: `${BASE_URL}/series/${sid}`,
            cover_url: "",
            alternate_titles: [],
            authors: [],
            artists: [],
            status: (),
            genres: [],
            tags: [],
            description: ()
        });
    }

    // Fallback: regex extraction if DOM parsing found nothing
    if series.len() == 0 {
        let aria_matches = regex_find_all("aria-label=\"Open series ([^\"]+)\"", html);
        let href_matches = regex_find_all("href=\"(/series/[A-Z0-9]{20,})\"", html);

        // Build a map of href -> sid
        let href_sids = [];
        for h in href_matches {
            let sid = h.replace("href=\"/series/", "").replace("\"", "");
            if sid.len() >= 20 && !href_sids.contains(sid) {
                href_sids.push(sid);
            }
        }

        // Try to pair titles with IDs
        let title_list = [];
        for a in aria_matches {
            let t = a.replace("aria-label=\"Open series ", "").replace("\"", "");
            if t != "" {
                title_list.push(t);
            }
        }

        // Use unique IDs and pair with titles where possible
        let unique_sids = [];
        for sid in href_sids {
            if seen[sid] == () {
                seen[sid] = true;
                unique_sids.push(sid);
            }
        }

        let i = 0;
        for sid in unique_sids {
            let title = if i < title_list.len() { title_list[i] } else { `Series ${sid.sub_string(0, 8)}` };
            series.push(#{
                id: sid,
                title: title,
                url: `${BASE_URL}/series/${sid}`,
                cover_url: "",
                alternate_titles: [],
                authors: [],
                artists: [],
                status: (),
                genres: [],
                tags: [],
                description: ()
            });
            i += 1;
        }
    }

    series
}

// ============================================================================
// Required Interface Functions
// ============================================================================

/// Returns metadata about this source
fn get_source_info() {
    #{
        id: "kagane-rhai",
        name: "Kagane",
        base_url: BASE_URL,
        language: "en",
        supported_languages: ["en"],
        requires_authentication: false,
        capability_level: "browser_automation"
    }
}

/// Browse manga (main browse endpoint)
fn browse(page, filters, auth) {
    get_latest_updates(page, auth)
}

/// Get latest updates from homepage
fn get_latest_updates(page, auth) {
    let url = BASE_URL;
    if page > 1 {
        url = `${BASE_URL}/?page=${page}`;
    }

    let html = fetch_page(url, "a[aria-label^='Open series']");

    if html == "" || !has_real_content(html) {
        return #{ series: [], has_more: false };
    }

    let series = extract_series_list(html);
    let has_more = series.len() > 0 && page < 20;

    #{ series: series, has_more: has_more }
}

/// Search for manga matching a query
fn search_series(query, page, auth) {
    let encoded = url_encode(query);
    let url = `${BASE_URL}/search?q=${encoded}`;
    if page > 1 {
        url = `${url}&page=${page}`;
    }

    let html = fetch_page(url, "a[aria-label^='Open series']");

    if html == "" || !has_real_content(html) {
        return #{ series: [], has_more: false, total: 0 };
    }

    let series = extract_series_list(html);
    let has_more = series.len() > 0 && html.contains(`page=${page + 1}`);

    #{ series: series, has_more: has_more, total: () }
}

/// Get detailed series information
fn get_series(id_or_url, auth) {
    let sid = id_or_url;

    if id_or_url.starts_with("http") {
        sid = extract_series_id(id_or_url);
    } else if id_or_url.starts_with("/series/") {
        sid = id_or_url.replace("/series/", "");
    }

    if sid == "" {
        throw `Invalid series ID: ${id_or_url}`;
    }

    let url = `${BASE_URL}/series/${sid}`;
    let html = fetch_page(url, "h1");

    if html == "" || !has_real_content(html) {
        throw `Failed to fetch series (browser required): ${sid}`;
    }

    // Title — h1 element
    let title = "";
    let title_els = html_select(html, "h1");
    if title_els.len() > 0 {
        title = element_text(title_els[0]).trim();
    }
    // Fallback: <title> tag (format: "Title - Kagane" or similar)
    if title == "" {
        let title_match = regex_find("<title>([^<]+)</title>", html);
        if title_match != "" {
            title = title_match.replace("<title>", "").replace("</title>", "");
            let dash_idx = title.index_of(" - ");
            if dash_idx > 0 {
                title = title.sub_string(0, dash_idx).trim();
            }
        }
    }

    // Description — <meta name="description" content="...">
    let description = ();
    let desc_match = regex_find("meta name=\"description\" content=\"([^\"]+)\"", html);
    if desc_match != "" {
        // Extract just the content value
        let content_start = desc_match.index_of("content=\"");
        if content_start >= 0 {
            let content = desc_match.sub_string(content_start + 9);
            // Remove trailing quote if present
            if content.ends_with("\"") {
                content = content.sub_string(0, content.len() - 1);
            }
            description = content.trim();
        }
    }

    // Status — look for ONGOING/COMPLETED/HIATUS/CANCELLED in spans
    let status = ();
    let status_match = regex_find(">(ONGOING|COMPLETED|HIATUS|CANCELLED)<", html);
    if status_match != "" {
        let clean = status_match.replace(">", "").replace("<", "");
        status = map_status(clean);
    }

    // Genres — spans with aria-label="Search by genre: {Genre}"
    let genres = [];
    let genre_spans = html_select(html, "span[aria-label]");
    for span in genre_spans {
        let aria = element_attr(span, "aria-label");
        if aria != () && aria != "" && aria.starts_with("Search by genre: ") {
            let genre = aria.sub_string(17).trim();
            if genre != "" && genre.len() < 50 && !genres.contains(genre) {
                genres.push(genre);
            }
        }
    }
    // Regex fallback for genres
    if genres.len() == 0 {
        let genre_matches = regex_find_all("Search by genre: ([^\"]+)\"", html);
        for g in genre_matches {
            let genre = g.replace("Search by genre: ", "").replace("\"", "").trim();
            if genre != "" && genre.len() < 50 && !genres.contains(genre) {
                genres.push(genre);
            }
        }
    }

    #{
        id: sid,
        title: title,
        alternate_titles: [],
        description: description,
        cover_url: "",
        authors: [],
        artists: [],
        status: status,
        genres: genres,
        tags: [],
        year: (),
        content_rating: "nsfw",
        url: url,
        extra: #{}
    }
}

/// Get all chapters for a series
fn get_chapters(series_id, auth) {
    let sid = series_id;

    if series_id.starts_with("http") {
        sid = extract_series_id(series_id);
    } else if series_id.starts_with("/series/") {
        sid = series_id.replace("/series/", "");
    }

    let url = `${BASE_URL}/series/${sid}`;
    let html = fetch_page(url, "a[href*='/reader/']");

    if html == "" || !has_real_content(html) {
        return [];
    }

    let chapters = [];
    let seen = #{};

    // Find all reader links: a[href*="/reader/"]
    let chapter_links = html_select(html, "a[href*='/reader/']");

    for link in chapter_links {
        let href = element_attr(link, "href");
        if href == () || href == "" {
            continue;
        }

        // Must be a reader link for this series
        if !href.contains("/reader/") {
            continue;
        }

        let ch_id = extract_chapter_id(href);
        if ch_id == "" || seen[ch_id] != () {
            continue;
        }
        seen[ch_id] = true;

        // Chapter title from inner h3 (e.g., "Ch. 1")
        let chapter_title = "";
        let h3_els = html_select(link, "h3");
        if h3_els.len() > 0 {
            chapter_title = element_text(h3_els[0]).trim();
        }
        if chapter_title == "" {
            // Try element_select_first as fallback
            try {
                let h3 = element_select_first(link, "h3");
                if h3 != "" && h3 != () {
                    chapter_title = element_text(h3).trim();
                }
            } catch {}
        }

        // Extract chapter number from title text ("Ch. N" -> N)
        let chapter_num = "0";
        if chapter_title != "" {
            let num_match = regex_find("\\d+\\.?\\d*", chapter_title);
            if num_match != "" {
                chapter_num = num_match;
            }
        }

        // Fallback: try extracting chapter number from hash fragment
        // href: /series/{SID}/reader/{CID}#chapter-N-slug
        if chapter_num == "0" {
            let hash_match = regex_find("#chapter-(\\d+)", href);
            if hash_match != "" {
                chapter_num = regex_find("\\d+", hash_match);
            }
        }

        // Last resort: sequential numbering
        if chapter_num == "0" {
            chapter_num = `${chapters.len() + 1}`;
        }

        if chapter_title == "" {
            chapter_title = `Chapter ${chapter_num}`;
        }

        // Build full reader URL (without hash for cleaner URL)
        let reader_url = href;
        if !reader_url.starts_with("http") {
            reader_url = `${BASE_URL}${href}`;
        }

        chapters.push(#{
            id: `${sid}/reader/${ch_id}`,
            series_id: sid,
            number: chapter_num,
            title: chapter_title,
            volume: (),
            language: "en",
            scanlator: (),
            url: reader_url,
            published_at: (),
            page_count: (),
            extra: #{
                chapter_hash: ch_id
            }
        });
    }

    // Regex fallback if DOM parsing found nothing
    if chapters.len() == 0 {
        let reader_patterns = regex_find_all("href=\"(/series/[^\"]+/reader/[^\"]+)\"", html);
        for pattern in reader_patterns {
            let href = regex_find("/series/[^\"]+/reader/[^\"#]+", pattern);
            if href == "" {
                continue;
            }

            let ch_id = extract_chapter_id(href);
            if ch_id == "" || seen[ch_id] != () {
                continue;
            }
            seen[ch_id] = true;

            // Try chapter number from hash
            let chapter_num = `${chapters.len() + 1}`;
            let hash_match = regex_find("#chapter-(\\d+)", pattern);
            if hash_match != "" {
                let n = regex_find("\\d+", hash_match);
                if n != "" {
                    chapter_num = n;
                }
            }

            chapters.push(#{
                id: `${sid}/reader/${ch_id}`,
                series_id: sid,
                number: chapter_num,
                title: `Chapter ${chapter_num}`,
                volume: (),
                language: "en",
                scanlator: (),
                url: `${BASE_URL}${href}`,
                published_at: (),
                page_count: (),
                extra: #{
                    chapter_hash: ch_id
                }
            });
        }
    }

    chapters
}

/// Get page URLs for a chapter
fn get_chapter_pages(chapter_id, auth) {
    let url = "";

    // chapter_id format: {series_id}/reader/{chapter_hash}
    if chapter_id.starts_with("http") {
        url = chapter_id;
    } else if chapter_id.contains("/reader/") {
        url = `${BASE_URL}/series/${chapter_id}`;
    } else {
        url = `${BASE_URL}/series/${chapter_id}`;
    }

    // JavaScript to extract image URLs from the rendered reader page.
    // Kagane uses blob: URLs for images, so we try multiple strategies:
    // 1. Find <img> elements with real (non-blob) src
    // 2. Look for image data in React state / __NEXT_DATA__
    // 3. Intercept image URLs from network requests cached in JS variables
    // 4. Extract from canvas elements if images are drawn to canvas
    let script = `
        (function() {
            var urls = [];

            // Strategy 1: Find all img elements with non-blob src
            var imgs = document.querySelectorAll('img');
            imgs.forEach(function(img) {
                var src = img.src || img.dataset.src || '';
                if (src && src.startsWith('http') && !src.includes('logo') && !src.includes('icon') && !src.includes('avatar') && !src.includes('favicon')) {
                    urls.push(src);
                }
            });

            if (urls.length > 0) {
                return JSON.stringify(urls);
            }

            // Strategy 2: Check __NEXT_DATA__ for image URLs
            var nextData = document.getElementById('__NEXT_DATA__');
            if (nextData) {
                try {
                    var data = JSON.parse(nextData.textContent);
                    var jsonStr = JSON.stringify(data);
                    var imgMatches = jsonStr.match(/https?:\/\/[^"]+\\.(?:jpg|jpeg|png|webp|gif)(?:\\?[^"]*)?/g);
                    if (imgMatches && imgMatches.length > 0) {
                        return JSON.stringify(imgMatches);
                    }
                } catch(e) {}
            }

            // Strategy 3: Search all script tags for image URL arrays
            var scripts = document.getElementsByTagName('script');
            for (var i = 0; i < scripts.length; i++) {
                var text = scripts[i].textContent || '';
                // Look for arrays of image URLs
                var arrayMatch = text.match(/\["(https?:\/\/[^"]+\\.(?:jpg|jpeg|png|webp)(?:\\?[^"]*)?)"(?:\s*,\s*"(https?:\/\/[^"]+\\.(?:jpg|jpeg|png|webp)(?:\\?[^"]*)?)")+\]/);
                if (arrayMatch) {
                    return arrayMatch[0];
                }
                // Look for individual image URL assignments
                var urlMatches = text.match(/https?:\/\/[^\s"']+\\.(?:jpg|jpeg|png|webp|gif)(?:\?[^\s"']*)?/g);
                if (urlMatches && urlMatches.length > 2) {
                    return JSON.stringify(urlMatches);
                }
            }

            // Strategy 4: Check for canvas elements (DRM rendering)
            var canvases = document.querySelectorAll('canvas');
            if (canvases.length > 0) {
                return JSON.stringify({"canvas_drm": true, "count": canvases.length});
            }

            // Strategy 5: Look for blob URLs (last resort - report them)
            var blobUrls = [];
            imgs.forEach(function(img) {
                if (img.src && img.src.startsWith('blob:')) {
                    blobUrls.push(img.src);
                }
            });
            if (blobUrls.length > 0) {
                return JSON.stringify({"blob_urls": blobUrls.length});
            }

            return '[]';
        })()
    `;

    let pages = [];

    // Must use browser — reader content is entirely client-rendered
    let result = fetch_page_with_script(url, "img, canvas, div.reader", script);
    let html = result.html;
    let script_result = result.script_result;

    // Try to parse image URLs from script execution
    if script_result != "" && script_result != "[]" {
        try {
            let parsed = json_parse(script_result);
            if parsed != () {
                // Check if it's an array of URLs
                if type_of(parsed) == "array" {
                    let idx = 0;
                    for img_url in parsed {
                        if img_url != () && img_url != "" && !img_url.contains("blob:") {
                            let full_url = img_url;
                            if !full_url.starts_with("http") {
                                if full_url.starts_with("//") {
                                    full_url = `https:${full_url}`;
                                } else if full_url.starts_with("/") {
                                    full_url = `${BASE_URL}${full_url}`;
                                }
                            }

                            pages.push(#{
                                index: idx,
                                url: full_url,
                                headers: #{
                                    "Referer": url
                                },
                                referer: url
                            });
                            idx += 1;
                        }
                    }
                }
            }
        } catch {
            // Script result wasn't valid JSON array, continue to HTML parsing
        }
    }

    // Fallback: parse images from rendered HTML
    if pages.len() == 0 && html != "" {
        let idx = 0;
        let seen = #{};

        // Try various image selectors
        let page_imgs = html_select(html, "img");
        for img in page_imgs {
            let src = element_attr(img, "src");
            if src == () || src == "" {
                src = element_attr(img, "data-src");
            }
            if src == () || src == "" {
                continue;
            }

            // Skip non-page images and blob URLs
            if src.starts_with("blob:") || src.contains("logo") || src.contains("icon") ||
               src.contains("avatar") || src.contains("banner") || src.contains("favicon") {
                continue;
            }

            if seen[src] != () {
                continue;
            }
            seen[src] = true;

            let full_url = src;
            if !full_url.starts_with("http") {
                if full_url.starts_with("//") {
                    full_url = `https:${full_url}`;
                } else if full_url.starts_with("/") {
                    full_url = `${BASE_URL}${full_url}`;
                }
            }

            pages.push(#{
                index: idx,
                url: full_url,
                headers: #{
                    "Referer": url
                },
                referer: url
            });
            idx += 1;
        }
    }

    // If still no pages, try regex extraction from HTML for any image URLs
    if pages.len() == 0 && html != "" {
        let img_urls = regex_find_all("\"(https?://[^\"]+\\.(?:jpg|jpeg|png|webp|gif)(?:\\?[^\"]*)?)\"", html);
        let idx = 0;
        let seen = #{};

        for raw in img_urls {
            let img_url = raw.replace("\"", "");
            if img_url.contains("logo") || img_url.contains("icon") || img_url.contains("avatar") ||
               img_url.contains("thumb") || img_url.contains("favicon") {
                continue;
            }
            if seen[img_url] != () {
                continue;
            }
            seen[img_url] = true;

            pages.push(#{
                index: idx,
                url: img_url,
                headers: #{
                    "Referer": url
                },
                referer: url
            });
            idx += 1;
        }
    }

    pages
}
